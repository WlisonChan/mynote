**java内存模型**

​		Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

​		由于java中的每个线程有自己的工作空间，因此多个线程在处理一个**共享变量**的时候，就会出现线程安全问题。

#### 		**volatile可以保证共享变量的可见性**。

即如果一个共享变量被一个线程修改了之后，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的**工作空间**中读取。

​		原理：（缓存一致性）线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。

#### 		**volatile可以保证共享变量的有序性**。

例子：在单例的双检锁模式下，需要在单例上加volatile关键字，因为计算机为了提高执行效率，会做指令重排的优化。在实例化单例的过程中，主要由以下步骤组成：

1、给 singleton 分配内存

2、调用 Singleton 的构造函数来初始化成员变量，形成实例

3、将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）

​		经过指令重排的优化之后，最终的顺序可能是1-2-3，也可能是1-3-2，如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。**注意：volatile阻止的不是singleton = new Singleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）。**（volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障，这样，在它的赋值完成之前，就不用会调用读操作。）

#### 		**volatile不能保证共享变量的原子性**。

​		对于t=t+1的操作或者t++的操作。线程1执行了加1的操作，此时t = 1。但是这个时候，处理器还没有把t = 1的值写回主存中。这个时候处理器跑去执行线程2，注意，刚才线程2已经读取了t的值，所以这个时候并不会再去读取t的值了，所以此时t的值还是0，然后线程2执行了对t的加1操作，此时t =1 。

​		