**新生代收集器：**Serial、ParNew、Parallel Scavenge； 

**老年代收集器：**Serial Old、Parallel Old、CMS； 

**整堆收集器：**G1、ZGC； 



##### **新生代垃圾收集器** 

- ###### Serial收集器 （STW 进行垃圾收集时，必须暂停所有工作线程，直到完成）

  - 针对新生代； 
  - 采用复制算法；
  - 单线程收集； 

- ###### ParNew收集器

  - 除了多线程外，其余的行为、特点和Serial收集器一样； 

- ###### Parallel Scavenge收集器 

  - 新生代收集器； 

  - 采用复制算法； 

  - 多线程收集； 

  - Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）； 

    吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；   

    高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间； 

##### **老年代垃圾收集器**

- ###### Serial Old收集器 

  - 采用"标记-整理"算法； 
  - 单线程收集； 

- ###### Parallel Old收集器 

  - 采用"标记-整理"算法； 

  - 多线程收集； 

    （注重吞吐量） 

- ###### CMS收集器 

  - 基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；
  - 以获取最短回收停顿时间为目标； 
  - 并发收集、低停顿； 
  - 需要更多的内存； 
  - 过程： 
    - 1）初始标记 : 仅标记以下GC root跟关联到的对象，速度很快，但需要stw； 
    - 2）并发标记 : 进行GC root Tracing的过程； 在刚才产生的集合中标记出存活的对象； 应用程序也在运行； 但是并不能保证可以标记出所有的存活对象； 
    - 3）重新标记 ： 为了修正并发标记期间因用户程序继续运行而导致标记变动的那一部分对象的标记记录； 采用多线程并发执行来提升效率； 需要stw； 
    - 4）并发清除 ： 回收所有的垃圾对象； 



###### <u>**有人会好奇为什么标记清理算法会产生内存碎片！但是CMS仍采用这种算法呢？**</u> 

答案：因为CMS作为第一款实现用户线程和收集线程并发执行的收集器！当时的设计理念是减少停顿时间，最好是能并发执行！但是问题来了，如要用户线程也在执行，那么就不能轻易的改变堆中对象的内存地址！不然会导致用户线程无法定位引用对象，从而无法正常运行！而标记整理算法和复制算法都会移动存活的对象，这就与上面的策略不符！因此CMS采用的是标记清理算法！



- ###### G1收集器（Garbage-First） 

  - 将整个堆划分位多个大小相等的独立区域（Region） 
  - 新生代和老年代不再是物理隔离，它们都是一部分Region不需要连续的集合； 
  - 执行过程与CMS相像： 
    - 1）初始标记 ：仅标记以下GC roots能直接关联到的对象，需要stw，但速度很快 。
    - 2）并发标记  : 进行Gcroot Tracing的过程； 刚才产生的集合中标记出存活对象 ;不能保证可以标记出所有的存活对象。
    - 3）最终标记  : 修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录 。
    - 4）筛选回收  ： 排序各个Region的回收价值和成本； 根据用户期望的GC停顿时间来指定回收计划； 最后按计划回收一些价值高的Region中垃圾对象； 

回收时采用复制算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在过程中压缩和释放内存。 

从整体看，是基于标记-整理算法； 

从局部（两个Region间）看，是基于复制算法； 

能充分利用多CPU、多核环境下的硬件优势； 

可以并行来缩短stw停顿时间； 

可以并发让垃圾收集与用户程序同时进行； 

对每个region里的回收对象价值（**回收该区域的时间消耗和能得到的内存比值**）进行分析，在最后筛选回收阶段，对每个region里的回收对象价值（回收该区域的时间消耗和能得到的内存比值）最后进行排序，用户可以自定义停顿时间，那么G1就可以对部分的region进行回收！这使得停顿时间是用户自己可以控制的！



- ###### ZGC

 